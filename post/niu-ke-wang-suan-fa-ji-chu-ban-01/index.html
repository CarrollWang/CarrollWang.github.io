<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>牛客网算法基础班（01） | 我爱你啊</title>
<meta name="description" content="一生所求，爱与自由.">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://carrollwang.github.io//favicon.ico?v=1573897346116">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://carrollwang.github.io//styles/main.css">



<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>

<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />



  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://carrollwang.github.io/">
        <img src="https://carrollwang.github.io//images/avatar.png?v=1573897346116" class="site-logo">
        <h1 class="site-title">我爱你啊</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="https://carrollwang.github.io//tags" class="site-nav">
            分类
          </a>
        
      
        
          <a href="https://carrollwang.github.io//archives" class="site-nav">
            汇总
          </a>
        
      
        
          <a href="https://carrollwang.github.io//post/qi-ji-yin-qiao/" class="site-nav">
            奇技淫巧
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      一生所求，爱与自由.
    </div>
    <div class="site-footer">
       | <a class="rss" href="https://carrollwang.github.io//atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">牛客网算法基础班（01）</h2>
            <div class="post-date">2019-11-09</div>
            
            <div class="post-content">
              <p>一.时间复杂度</p>
<blockquote>
<blockquote>
<p>常数时间的操作：一个操作如果和数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。时间复杂度为一个算法流程中，常数操作数量的指标。常用O（读作big O）来表示。具体来说，在常数操作数量的表达式中只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分如果记为f(N)，那么时间复杂度为O(f(N))。评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是常数项时</p>
</blockquote>
</blockquote>
<p>二.冒泡排序<br>
冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<p>1、算法步骤<br>
比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>
对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。<br>
针对所有的元素重复以上的步骤，除了最后一个。<br>
持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
<p>2、动图演示<br>
<img src="https://carrollwang.github.io//post-images/1573810335169.gif" alt=""><br>
代码实现：</p>
<pre><code class="language-java">public class BubbleSort implements IArraySort {
    @Override
    public int[] sort(int[] sourceArray) throws Exception {
// 对 arr 进行拷贝，不改变参数内容
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);
        for (int i = 1; i &lt; arr.length; i++) {
// 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。
            boolean flag = true;
            for (int j = 0; j &lt; arr.length - i; j++) {
                if (arr[j] &gt; arr[j + 1]) {
                    int tmp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = tmp;

                    flag = false;
                }
            }
            if (flag) {
                break;
            }
        }
        return arr;
    }
}
</code></pre>
<p>三.选择排序<br>
选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。<br>
1、算法步骤<br>
首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置<br>
再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。<br>
重复第二步，直到所有元素均排序完毕。<br>
2、动图演示<br>
<img src="https://carrollwang.github.io//post-images/1573810464016.gif" alt=""><br>
四.插入排序（扑克牌）<br>
动图<br>
<img src="https://carrollwang.github.io//post-images/1573309537523.gif" alt=""><br>
直接插入算法的执行过程<br>
<img src="https://carrollwang.github.io//post-images/1573309579191.jpg" alt=""></p>
<p>代码：</p>
<pre><code class="language-java">// 时间复杂度O(n^2)
    // 控件复杂度O(1)
    // 稳定性： 稳定
    // 内部排序
    for (int i = 0; i &lt; dataArr.count; i++) {
        for (int j = i; j &gt; 0; j--) {
            if ([dataArr[j] intValue] &lt; [dataArr[j - 1] intValue]) {
                [dataArr exchangeObjectAtIndex:j withObjectAtIndex:j-1];
            }
        }
    }
</code></pre>
<p>五.递归</p>
<blockquote>
<blockquote>
<p>master公式的使用<br>
T(N) = a*T(N/b) + O(N^d)</p>
</blockquote>
</blockquote>
<ol>
<li>log(b,a) &gt; d -&gt; 复杂度为O(N^log(b,a))</li>
<li>log(b,a) = d -&gt; 复杂度为O(N^d * logN)</li>
<li>log(b,a) &lt; d -&gt; 复杂度为O(N^d)</li>
</ol>
<p>六.归并排序<br>
时间复杂度O(N*logN)，额外空间复杂度O(N）<br>
归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p>
<p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：<br>
自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；<br>
自下而上的迭代；<br>
在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为：<br>
However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle.<br>
然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。<br>
说实话，我不太理解这句话。意思是 JavaScript 编译器内存太小，递归太深容易造成内存溢出吗？还望有大神能够指教。<br>
和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p>
<p>1、算法步骤<br>
申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；<br>
设定两个指针，最初位置分别为两个已经排序序列的起始位置；<br>
比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；<br>
重复步骤 3 直到某一指针达到序列尾；<br>
将另一序列剩下的所有元素直接复制到合并序列尾。<br>
2、动图演示<br>
<img src="https://carrollwang.github.io//post-images/1573816257191.gif" alt=""><br>
3.Java代码实现</p>
<pre><code class="language-java">public class MergeSort implements IArraySort {
@Override
public int[] sort(int[] sourceArray) throws Exception {
// 对 arr 进行拷贝，不改变参数内容
int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);
if (arr.length &lt; 2) {
return arr;
}
int middle = (int) Math.floor(arr.length / 2);
int[] left = Arrays.copyOfRange(arr, 0, middle);
int[] right = Arrays.copyOfRange(arr, middle, arr.length);
return merge(sort(left), sort(right));
}
protected int[] merge(int[] left, int[] right) {
int[] result = new int[left.length + right.length];
int i = 0;
while (left.length &gt; 0 &amp;&amp; right.length &gt; 0) {
if (left[0] &lt;= right[0]) {
result[i++] = left[0];
left = Arrays.copyOfRange(left, 1, left.length);
} else {
result[i++] = right[0];
right = Arrays.copyOfRange(right, 1, right.length);
}
}
while (left.length &gt; 0) {
result[i++] = left[0];
left = Arrays.copyOfRange(left, 1, left.length);
}
while (right.length &gt; 0) {
result[i++] = right[0];
right = Arrays.copyOfRange(right, 1, right.length);
}
return result;
}
}
</code></pre>
<p>七、快速排序<br>
快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p>
<p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p>
<p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p>
<p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案：</p>
<p>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p>
<p>1、算法步骤</p>
<p>从数列中挑出一个元素，称为 “基准”（pivot）;</p>
<p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p>
<p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</p>
<p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p>
<p>2、动图演示<br>
<img src="https://carrollwang.github.io//post-images/1573823339015.gif" alt=""></p>
<p>3、Java 代码实现</p>
<pre><code class="language-java">public class QuickSort implements IArraySort {
@Override
public int[] sort(int[] sourceArray) throws Exception {
// 对 arr 进行拷贝，不改变参数内容
int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);
return quickSort(arr, 0, arr.length - 1);
}
private int[] quickSort(int[] arr, int left, int right) {
if (left &lt; right) {
int partitionIndex = partition(arr, left, right);
quickSort(arr, left, partitionIndex - 1);
quickSort(arr, partitionIndex + 1, right);
}
return arr;
}
private int partition(int[] arr, int left, int right) {
// 设定基准值（pivot）
int pivot = left;
int index = pivot + 1;
for (int i = index; i &lt;= right; i++) {
if (arr[i] &lt; arr[pivot]) {
swap(arr, i, index);
index++;
}
}
swap(arr, pivot, index - 1);
return index - 1;
}
private void swap(int[] arr, int i, int j) {
int temp = arr[i];
arr[i] = arr[j];
arr[j] = temp;
}
}
</code></pre>
<p>七、堆排序<br>
堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：<br>
大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；<br>
小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</p>
<p>堆排序的平均时间复杂度为 Ο(nlogn)。<br>
1、算法步骤<br>
创建一个堆 H[0……n-1]；<br>
把堆首（最大值）和堆尾互换；<br>
把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；<br>
重复步骤 2，直到堆的尺寸为 1。</p>
<p>2、动图演示<br>
<img src="https://carrollwang.github.io//post-images/1573823493066.gif" alt=""></p>
<p>3、Java 代码实现</p>
<pre><code class="language-java">public class HeapSort implements IArraySort {
@Override
public int[] sort(int[] sourceArray) throws Exception {
// 对 arr 进行拷贝，不改变参数内容
int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);
int len = arr.length;
buildMaxHeap(arr, len);
for (int i = len - 1; i &gt; 0; i--) {
swap(arr, 0, i);
len--;
heapify(arr, 0, len);
}
return arr;
}
private void buildMaxHeap(int[] arr, int len) {
for (int i = (int) Math.floor(len / 2); i &gt;= 0; i--) {
heapify(arr, i, len);
}
}
private void heapify(int[] arr, int i, int len) {
int left = 2 * i + 1;
int right = 2 * i + 2;
int largest = i;
if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) {
largest = left;
}
if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) {
largest = right;
}
if (largest != i) {
swap(arr, i, largest);
heapify(arr, largest, len);
}
}
private void swap(int[] arr, int i, int j) {
int temp = arr[i];
arr[i] = arr[j];
arr[j] = temp;
}
}
</code></pre>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://carrollwang.github.io//tag/EkXpQRas6" class="tag">
                    数据结构与算法
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://carrollwang.github.io//post/shi-jian-fu-za-du-o1he-onde-qu-bie">
                  <h3 class="post-title">
                    时间复杂度O(1)和O(n)的区别
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>




  </body>
</html>
