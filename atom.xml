<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://carrollwang.github.io/</id>
    <title>我爱你啊</title>
    <updated>2019-11-16T04:36:39.616Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://carrollwang.github.io/"/>
    <link rel="self" href="https://carrollwang.github.io//atom.xml"/>
    <subtitle>一生所求，爱与自由.</subtitle>
    <logo>https://carrollwang.github.io//images/avatar.png</logo>
    <icon>https://carrollwang.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 我爱你啊</rights>
    <entry>
        <title type="html"><![CDATA[牛客网算法基础班（03）]]></title>
        <id>https://carrollwang.github.io//post/niu-ke-wang-suan-fa-ji-chu-ban-03</id>
        <link href="https://carrollwang.github.io//post/niu-ke-wang-suan-fa-ji-chu-ban-03">
        </link>
        <updated>2019-11-15T06:52:31.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>题目一：用数组结构实现大小固定的队列</p>
</blockquote>
<pre><code class="language-java">    System.out.println(&quot;Hello world！&quot;);
</code></pre>
<blockquote>
<p>题目二：实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。<br>
【要求】1．pop、push、getMin操作的时间复杂度都是O(1)。<br>
2．设计的栈类型可以使用现成的栈结</p>
</blockquote>
<pre><code class="language-java">    System.out.println(&quot;Hello world！&quot;);
</code></pre>
<blockquote>
<p>题目三：如何仅用队列结构实现栈结构？如何仅用栈结构实现队列结构？</p>
</blockquote>
<pre><code class="language-java">    System.out.println(&quot;Hello world！&quot;);
</code></pre>
<blockquote>
<p>题目四：猫狗队列 【题目】 宠物、狗和猫的类如下：public class Pet { private String type;public Pet(String type) { this.type = type; }public String getPetType() { return this.type; }}public class Dog extends Pet { public Dog() { super(&quot;dog&quot;); } }public class Cat extends Pet { public Cat() { super(&quot;cat&quot;); } }实现一种狗猫队列的结构，要求如下： 用户可以调用add方法将cat类或dog类的实例放入队列中； 用户可以调用pollAll方法，将队列中所有的实例按照进队列的先后顺序依次弹出； 用户可以调用pollDog方法，将队列中dog类的实例按照进队列的先后顺序依次弹出； 用户可以调用pollCat方法，将队列中cat类的实例按照进队列的先后顺序依次弹出； 用户可以调用isEmpty方法，检查队列中是否还有dog或cat的实例； 用户可以调用isDogEmpty方法，检查队列中是否有do类的实例； 用户可以调用isCatEmpty方法，检查队列中是否有cat类的实例。</p>
</blockquote>
<pre><code class="language-java">System.out.println(&quot;Hello world！&quot;);
</code></pre>
<blockquote>
<p>题目五：转圈打印矩阵<br>
【题目】 给定一个整型矩阵matrix，请按照转圈的方式打印它。<br>
例如： 1 2 3 4 5 6 7 8 9 10 11 12 13 14<br>
15 16 打印结果为：1，2，3，4，8，12，16，15，14，13，9，<br>
5，6，7，11， 10<br>
【要求】 额外空间复杂度为O(1)。</p>
</blockquote>
<pre><code class="language-java">System.out.println(&quot;Hello world！&quot;);
</code></pre>
<blockquote>
<p>题目六：旋转正方形矩阵【题目】 给定一个整型正方形矩阵matrix，请把该矩阵调整成顺时针旋转90度的样子。【要求】 额外空间复杂度为O(1).</p>
</blockquote>
<pre><code class="language-java">System.out.println(&quot;Hello world！&quot;);
</code></pre>
<blockquote>
<p>题目七：反转单向和双向链【题目】 分别实现反转单向链表和反转双向链表的函数。【要求】 如果链表长度为N，时间复杂度要求为O(N)，额外空间复杂度要求为O(1).</p>
</blockquote>
<pre><code class="language-java">System.out.println(&quot;Hello world！&quot;);
</code></pre>
<blockquote>
<p>题目八：“之”字形打印矩阵【题目】 给定一个矩阵matrix，按照“之”字形的方式打印这个矩阵，例如： 1 2 3 4 5 6 7 8 9  10 11 12“之”字形打印的结果为：1，2，5，9，6，3，4，7，10，11，8，12【要求】 额外空间复杂度为O(1).</p>
</blockquote>
<pre><code class="language-java">System.out.println(&quot;Hello world！&quot;);
</code></pre>
<blockquote>
<p>题目九：在行列都排好序的矩阵中找数<br>
【题目】 给定一个有N*M的整型矩阵matrix和一个整数K，<br>
matrix的每一行和每一 列都是排好序的。实现一个函数，判断K<br>
是否在matrix中。 例如： 0 1 2 5 2 3 4 7 4<br>
4 4 8 5 7 7 9 如果K为7，返回true；如果K为6，返<br>
回false。<br>
【要求】 时间复杂度为O(N+M)，额外空间复杂度为O(1)。</p>
</blockquote>
<pre><code class="language-java">System.out.println(&quot;Hello world！&quot;);
</code></pre>
<blockquote>
<p>题目十：打印两个有序链表的公共部分【题目】 给定两个有序链表的头指针head1和head2，打印两个链表的公共部分。</p>
</blockquote>
<pre><code class="language-java">System.out.println(&quot;Hello world！&quot;);
</code></pre>
<blockquote>
<p>题目十一：判断一个链表是否为回文结构【题目】 给定一个链表的头节点head，请判断该链表是否为回文结构。 例如： 1-&gt;2-&gt;1，返回true。 1-&gt;2-&gt;2-&gt;1，返回true。15-&gt;6-&gt;15，返回true。 1-&gt;2-&gt;3，返回false。进阶： 如果链表长度为N，时间复杂度达到O(N)，额外空间复杂度达到O(1).</p>
</blockquote>
<pre><code class="language-java">System.out.println(&quot;Hello world！&quot;);
</code></pre>
<blockquote>
<p>题目十二：将单向链表按某值划分成左边小、中间相等、右边大的形式【题目】 给定一个单向链表的头节点head，节点的值类型是整型，再给定一个整 数pivot。实现一个调整链表的函数，将链表调整为左部分都是值小于 pivot的节点，中间部分都是值等于pivot的节点，右部分都是值大于 pivot的节点。除这个要求外，对调整后的节点顺序没有更多的要求。 例如：链表9-&gt;0-&gt;4-&gt;5-&gt;1，pivot=3。 调整后链表可以是1-&gt;0-&gt;4-&gt;9-&gt;5，也可以是0-&gt;1-&gt;9-&gt;5-&gt;4。总之，满 足左部分都是小于3的节点，中间部分都是等于3的节点（本例中这个部分为空），右部分都是大于3的节点即可。对某部分内部的节点顺序不做 要求。进阶： 在原问题的要求之上再增加如下两个要求。在左、中、右三个部分的内部也做顺序要求，要求每部分里的节点从左 到右的顺序与原链表中节点的先后次序一致。 例如：链表9-&gt;0-&gt;4-&gt;5-&gt;1，pivot=3。调整后的链表是0-&gt;1-&gt;9-&gt;4-&gt;5。 在满足原问题要求的同时，左部分节点从左到右为0、1。在原链表中也 是先出现0，后出现1；中间部分在本例中为空，不再讨论；右部分节点 从左到右为9、4、5。在原链表中也是先出现9，然后出现4，最后出现5。如果链表长度为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1).</p>
</blockquote>
<pre><code class="language-java">System.out.println(&quot;Hello world！&quot;);
</code></pre>
<blockquote>
<p>题目十三：复制含有随机指针节点的链表【题目】 一种特殊的链表节点类描述如下：public class Node { public int value; public Node next; publiNode rand;public Node(int data) { this.value = data; }}Node类中的value是节点值，next指针和正常单链表中next指针的意义一 样，都指向下一个节点，rand指针是Node类中新增的指针，这个指针可 能指向链表中的任意一个节点，也可能指向null。 给定一个由Node节点类型组成的无环单链表的头节点head，请实现一个 函数完成这个链表中所有结构的复制，并返回复制的新链表的头节点。 进阶：不使用额外的数据结构，只用有限几个变量，且在时间复杂度为 O(N)内完成原问题要实现的函数。</p>
</blockquote>
<pre><code class="language-java">System.out.println(&quot;Hello world！&quot;);
</code></pre>
<blockquote>
<p>题目十四：两个单链表相交的一系列问题<br>
【题目】 在本题中，单链表可能有环，也可能无环。给定两个<br>
单链表的头节点 head1和head2，这两个链表可能相交，也可能<br>
不相交。请实现一个函数， 如果两个链表相交，请返回相交的<br>
第一个节点；如果不相交，返回null 即可。 要求：如果链表1<br>
的长度为N，链表2的长度为M，时间复杂度请达到 O(N+M)，额外<br>
空间复杂度请达到O(1)。</p>
</blockquote>
<pre><code class="language-java">System.out.println(&quot;Hello world！&quot;);
</code></pre>
<blockquote>
<blockquote>
<p>题目十五：二分的小扩展。</p>
</blockquote>
</blockquote>
<pre><code class="language-java">System.out.println(&quot;Hello world！&quot;);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[牛客网算法基础班（02）]]></title>
        <id>https://carrollwang.github.io//post/niu-ke-wang-suan-fa-ji-chu-ban-02</id>
        <link href="https://carrollwang.github.io//post/niu-ke-wang-suan-fa-ji-chu-ban-02">
        </link>
        <updated>2019-11-09T14:39:26.000Z</updated>
        <content type="html"><![CDATA[<p>一.随机快速排序<br>
时间复杂度O(N*logN)，额外空间复杂度O(logN)</p>
<p>二.堆排序<br>
堆排序的细节和复杂度分析时间复杂度O(N*logN)，额外空间复杂度O(1)堆结构非常重要1，堆结构的heapInsert与heapify2，堆结构的增大和减少3，如果只是建立堆的过程，时间复杂度为O(N)4，优先级队列结构，就是堆</p>
<p>稳定性：O（n2）的排序，冒泡排序和插入排序可以做到保证稳定性，选择排序做不到。<br>
题目：给定一个数组，求如果排序之后，相邻两数的最大差值，要求时间复杂度为O（N）,且要求不能用非基于比较的排序。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[牛客网算法基础班（01）]]></title>
        <id>https://carrollwang.github.io//post/niu-ke-wang-suan-fa-ji-chu-ban-01</id>
        <link href="https://carrollwang.github.io//post/niu-ke-wang-suan-fa-ji-chu-ban-01">
        </link>
        <updated>2019-11-09T14:20:02.000Z</updated>
        <content type="html"><![CDATA[<p>一.时间复杂度</p>
<blockquote>
<blockquote>
<p>常数时间的操作：一个操作如果和数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。时间复杂度为一个算法流程中，常数操作数量的指标。常用O（读作big O）来表示。具体来说，在常数操作数量的表达式中只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分如果记为f(N)，那么时间复杂度为O(f(N))。评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是常数项时</p>
</blockquote>
</blockquote>
<p>二.冒泡排序<br>
冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<p>1、算法步骤<br>
比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>
对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。<br>
针对所有的元素重复以上的步骤，除了最后一个。<br>
持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
<p>2、动图演示<br>
<img src="https://carrollwang.github.io//post-images/1573810335169.gif" alt=""><br>
代码实现：</p>
<pre><code class="language-java">public class BubbleSort implements IArraySort {
    @Override
    public int[] sort(int[] sourceArray) throws Exception {
// 对 arr 进行拷贝，不改变参数内容
        int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);
        for (int i = 1; i &lt; arr.length; i++) {
// 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。
            boolean flag = true;
            for (int j = 0; j &lt; arr.length - i; j++) {
                if (arr[j] &gt; arr[j + 1]) {
                    int tmp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = tmp;

                    flag = false;
                }
            }
            if (flag) {
                break;
            }
        }
        return arr;
    }
}
</code></pre>
<p>三.选择排序<br>
选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。<br>
1、算法步骤<br>
首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置<br>
再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。<br>
重复第二步，直到所有元素均排序完毕。<br>
2、动图演示<br>
<img src="https://carrollwang.github.io//post-images/1573810464016.gif" alt=""><br>
四.插入排序（扑克牌）<br>
动图<br>
<img src="https://carrollwang.github.io//post-images/1573309537523.gif" alt=""><br>
直接插入算法的执行过程<br>
<img src="https://carrollwang.github.io//post-images/1573309579191.jpg" alt=""></p>
<p>代码：</p>
<pre><code class="language-java">// 时间复杂度O(n^2)
    // 控件复杂度O(1)
    // 稳定性： 稳定
    // 内部排序
    for (int i = 0; i &lt; dataArr.count; i++) {
        for (int j = i; j &gt; 0; j--) {
            if ([dataArr[j] intValue] &lt; [dataArr[j - 1] intValue]) {
                [dataArr exchangeObjectAtIndex:j withObjectAtIndex:j-1];
            }
        }
    }
</code></pre>
<p>五.递归</p>
<blockquote>
<blockquote>
<p>master公式的使用<br>
T(N) = a*T(N/b) + O(N^d)</p>
</blockquote>
</blockquote>
<ol>
<li>log(b,a) &gt; d -&gt; 复杂度为O(N^log(b,a))</li>
<li>log(b,a) = d -&gt; 复杂度为O(N^d * logN)</li>
<li>log(b,a) &lt; d -&gt; 复杂度为O(N^d)</li>
</ol>
<p>六.归并排序<br>
时间复杂度O(N*logN)，额外空间复杂度O(N）<br>
归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p>
<p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：<br>
自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；<br>
自下而上的迭代；<br>
在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为：<br>
However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle.<br>
然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。<br>
说实话，我不太理解这句话。意思是 JavaScript 编译器内存太小，递归太深容易造成内存溢出吗？还望有大神能够指教。<br>
和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p>
<p>1、算法步骤<br>
申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；<br>
设定两个指针，最初位置分别为两个已经排序序列的起始位置；<br>
比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；<br>
重复步骤 3 直到某一指针达到序列尾；<br>
将另一序列剩下的所有元素直接复制到合并序列尾。<br>
2、动图演示<br>
<img src="https://carrollwang.github.io//post-images/1573816257191.gif" alt=""><br>
3.Java代码实现</p>
<pre><code class="language-java">public class MergeSort implements IArraySort {
@Override
public int[] sort(int[] sourceArray) throws Exception {
// 对 arr 进行拷贝，不改变参数内容
int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);
if (arr.length &lt; 2) {
return arr;
}
int middle = (int) Math.floor(arr.length / 2);
int[] left = Arrays.copyOfRange(arr, 0, middle);
int[] right = Arrays.copyOfRange(arr, middle, arr.length);
return merge(sort(left), sort(right));
}
protected int[] merge(int[] left, int[] right) {
int[] result = new int[left.length + right.length];
int i = 0;
while (left.length &gt; 0 &amp;&amp; right.length &gt; 0) {
if (left[0] &lt;= right[0]) {
result[i++] = left[0];
left = Arrays.copyOfRange(left, 1, left.length);
} else {
result[i++] = right[0];
right = Arrays.copyOfRange(right, 1, right.length);
}
}
while (left.length &gt; 0) {
result[i++] = left[0];
left = Arrays.copyOfRange(left, 1, left.length);
}
while (right.length &gt; 0) {
result[i++] = right[0];
right = Arrays.copyOfRange(right, 1, right.length);
}
return result;
}
}
</code></pre>
<p>七、快速排序<br>
快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p>
<p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p>
<p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p>
<p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案：</p>
<p>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p>
<p>1、算法步骤</p>
<p>从数列中挑出一个元素，称为 “基准”（pivot）;</p>
<p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p>
<p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</p>
<p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p>
<p>2、动图演示<br>
<img src="https://carrollwang.github.io//post-images/1573823339015.gif" alt=""></p>
<p>3、Java 代码实现</p>
<pre><code class="language-java">public class QuickSort implements IArraySort {
@Override
public int[] sort(int[] sourceArray) throws Exception {
// 对 arr 进行拷贝，不改变参数内容
int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);
return quickSort(arr, 0, arr.length - 1);
}
private int[] quickSort(int[] arr, int left, int right) {
if (left &lt; right) {
int partitionIndex = partition(arr, left, right);
quickSort(arr, left, partitionIndex - 1);
quickSort(arr, partitionIndex + 1, right);
}
return arr;
}
private int partition(int[] arr, int left, int right) {
// 设定基准值（pivot）
int pivot = left;
int index = pivot + 1;
for (int i = index; i &lt;= right; i++) {
if (arr[i] &lt; arr[pivot]) {
swap(arr, i, index);
index++;
}
}
swap(arr, pivot, index - 1);
return index - 1;
}
private void swap(int[] arr, int i, int j) {
int temp = arr[i];
arr[i] = arr[j];
arr[j] = temp;
}
}
</code></pre>
<p>七、堆排序<br>
堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：<br>
大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；<br>
小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</p>
<p>堆排序的平均时间复杂度为 Ο(nlogn)。<br>
1、算法步骤<br>
创建一个堆 H[0……n-1]；<br>
把堆首（最大值）和堆尾互换；<br>
把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；<br>
重复步骤 2，直到堆的尺寸为 1。</p>
<p>2、动图演示<br>
<img src="https://carrollwang.github.io//post-images/1573823493066.gif" alt=""></p>
<p>3、Java 代码实现</p>
<pre><code class="language-java">public class HeapSort implements IArraySort {
@Override
public int[] sort(int[] sourceArray) throws Exception {
// 对 arr 进行拷贝，不改变参数内容
int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);
int len = arr.length;
buildMaxHeap(arr, len);
for (int i = len - 1; i &gt; 0; i--) {
swap(arr, 0, i);
len--;
heapify(arr, 0, len);
}
return arr;
}
private void buildMaxHeap(int[] arr, int len) {
for (int i = (int) Math.floor(len / 2); i &gt;= 0; i--) {
heapify(arr, i, len);
}
}
private void heapify(int[] arr, int i, int len) {
int left = 2 * i + 1;
int right = 2 * i + 2;
int largest = i;
if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) {
largest = left;
}
if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) {
largest = right;
}
if (largest != i) {
swap(arr, i, largest);
heapify(arr, largest, len);
}
}
private void swap(int[] arr, int i, int j) {
int temp = arr[i];
arr[i] = arr[j];
arr[j] = temp;
}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[时间复杂度O(1)和O(n)的区别]]></title>
        <id>https://carrollwang.github.io//post/shi-jian-fu-za-du-o1he-onde-qu-bie</id>
        <link href="https://carrollwang.github.io//post/shi-jian-fu-za-du-o1he-onde-qu-bie">
        </link>
        <updated>2019-10-30T14:26:51.000Z</updated>
        <content type="html"><![CDATA[<p>O(1)解析<br>
O(1)就是最低的时空复杂度了，也就是耗时/耗空间与输入数据大小无关，无论输入数据增大多少倍，耗时/耗空间都不变。 哈希算法就是典型的O(1)时间复杂度，无论数据规模多大，都可以在一次计算后找到目标（不考虑冲突的话），冲突的话很麻烦的，指向的value会做二次hash到另外一快存储区域。</p>
<p>通俗易懂的例子</p>
<p>什么是O(1)呢，就比如你是一个酒店的管理员，你负责管理酒店的钥匙，你很聪明，你把酒店的100把钥匙放在了100个格子里面存着，并且把格子从1~100进行了编号，有一天有客人来了，酒店老板说，给我拿10号房间的钥匙给我，你迅速从10号格子里面拿出钥匙给老板，速度非常快，这时候你就是一个电脑了，老板跟你说拿几号房房间的钥匙，你只需要看一眼就能知道钥匙在哪里。</p>
<p>O(n)解析<br>
比如时间复杂度为O(n)，就代表数据量增大几倍，耗时也增大几倍。</p>
<p>比如常见的遍历算法。</p>
<p>要找到一个数组里面最大的一个数，你要把n个变量都扫描一遍，操作次数为n，那么算法复杂度是O(n).</p>
<p>通俗易懂的例子</p>
<p>突然，有一天，你的老板给你说，你用100个箱子存100把钥匙，太浪费空间了，你能补能把钥匙上编号一下，然后把钥匙要用绳子穿起来，这样我们可以把这个放箱子的地方再装修一个房间出来。你想了一下，是啊，现在房价这么贵，这样能多赚点钱。所以你就不能通过上面的方法来找到钥匙了，老板跟你说，给我拿45号房间的钥匙出来，你就需要从100个钥匙里面挨个找45个房间的钥匙。</p>
<p>从<br>
原文链接：https://blog.csdn.net/lkp1603645756/article/details/85013126</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线性表]]></title>
        <id>https://carrollwang.github.io//post/xian-xing-biao</id>
        <link href="https://carrollwang.github.io//post/xian-xing-biao">
        </link>
        <updated>2019-10-30T12:33:41.000Z</updated>
        <content type="html"><![CDATA[<p>定义：另个或者多个数据元素的有限序列。<br>
1.首先他是一序列，也就是说，元素之间是有顺序的。<br>
2、线性表强调是有限的，元素个数是有限的。事实上，在计算机中处理的对象都是有限的，那种无限的数列，只存在于数学的概念中<br>
3.线性表元素的个数n（n&gt;=0）定义为线性表的长度，当n=0时，称为空表。<br>
4.相同类型的数据<br>
5.<img src="https://carrollwang.github.io//post-images/1572439397394.png" alt=""><br>
6.线性表的顺序存储结构，指的是用一段地址连续的存储单元一次存储线性表的数据元素。<br>
7.<img src="https://carrollwang.github.io//post-images/1572442158486.png" alt=""><br>
描述顺序存储结构需要三个属性：</p>
<blockquote>
<p>①存储空间的起始位置：数组data,它的存储位置就是存储空间的存储位置<br>
②线性表的最大存储容量：数组长度MaxSize<br>
③线性表的当前长度：length</p>
</blockquote>
<p>8.数组的长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的。<br>
线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。<br>
在任意时刻，线性表的长度应该小于等于数组的长度。<br>
数组的长度：<br>
线性表的长度：<br>
9.<img src="https://carrollwang.github.io//post-images/1572443012065.png" alt=""><br>
<img src="https://carrollwang.github.io//post-images/1572443020652.png" alt=""><br>
10.<img src="https://carrollwang.github.io//post-images/1572443516001.png" alt=""><br>
11.结点由存放数据元素的数据域和存放后继结点地址的指针域组成<br>
12.#单链表的读取</p>
<blockquote>
<p>获得链表第i个数据的算法思路<br>
a、声明一个结点p指向链表第一个结点，初始化j从1开始。<br>
b、当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1。<br>
c、若到链表末尾P为空，则说明第i个元素不存在。<br>
d、否则查找成功，返回结点P的数据。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[05讲数组：为什么很多编程语言中数组都从0开始编号]]></title>
        <id>https://carrollwang.github.io//post/05-jiang-shu-zu-wei-shi-me-hen-duo-bian-cheng-yu-yan-zhong-shu-zu-du-cong-0-kai-shi-bian-hao</id>
        <link href="https://carrollwang.github.io//post/05-jiang-shu-zu-wei-shi-me-hen-duo-bian-cheng-yu-yan-zhong-shu-zu-du-cong-0-kai-shi-bian-hao">
        </link>
        <updated>2019-10-28T08:52:19.000Z</updated>
        <content type="html"><![CDATA[<p>##数组看起来简单基础，但是很多人没有理解这个数据结构的精髓。带着为什么数组要从0开始编号，而不是从1开始的问题，进入主题。</p>
<ol>
<li>数组如何实现随机访问<br>
1）	数组是一种线性数据结构，用连续的存储空间存储相同类型数据<br>
I）	线性表：数组、链表、队列、栈 非线性表：树 图<br>
II）	连续的内存空间、相同的数据，所以数组可以随机访问，但对数组进行删除插入，为了保证数组的连续性，就要做大量的数据搬移工作<br>
a)	数组如何实现下标随机访问。<br>
引入数组再内存种的分配图，得出寻址公式<br>
b)	纠正数组和链表的错误认识。数组的查找操作时间复杂度并不是O(1)。即便是排好的数组，用二分查找，时间复杂度也是O（logn）。<br>
正确表述：数组支持随机访问，根据下标随机访问的时间复杂度为O（1）</li>
<li>低效的插入和删除<br>
1）	插入：从最好O(1) 最坏O(n) 平均O(n)<br>
2）	插入：数组若无序，插入新的元素时，可以将第K个位置元素移动到数组末尾，把心的元素，插入到第k个位置，此处复杂度为O(1)。作者举例说明<br>
3）	删除：从最好O(1) 最坏O(n) 平均O(n)<br>
4）	多次删除集中在一起，提高删除效率<br>
记录下已经被删除的数据，每次的删除操作并不是搬移数据，只是记录数据已经被删除，当数组没有更多的存储空间时，再触发一次真正的删除操作。即JVM标记清除垃圾回收算法。</li>
<li>警惕数组的访问越界问题<br>
用C语言循环越界访问的例子说明访问越界的bug。此例在《C陷阱与缺陷》出现过，很惭愧，看过但是现在也只有一丢丢印象。翻了下书，替作者加上一句话：如果用来编译这段程序的编译器按照内存地址递减的方式给变量分配内存，那么内存中的i将会被置为0，则为死循环永远出不去。</li>
<li>容器能否完全替代数组<br>
相比于数字，java中的ArrayList封装了数组的很多操作，并支持动态扩容。一旦超过村塾容量，扩容时比较耗内存，因为涉及到内存申请和数据搬移。<br>
数组适合的场景：<br>
1）	Java ArrayList 的使用涉及装箱拆箱，有一定的性能损耗，如果特别管柱性能，可以考虑数组<br>
2）	若数据大小事先已知，并且涉及的数据操作非常简单，可以使用数组<br>
3）	表示多维数组时，数组往往更加直观。<br>
4）	业务开发容器即可，底层开发，如网络框架，性能优化。选择数组。</li>
<li>解答开篇问题<br>
1）	从偏移角度理解a[0] 0为偏移量，如果从1计数，会多出K-1。增加cpu负担。为什么循环要写成for(int i = 0;i&lt;3;i++) 而不是for(int i = 0 ;i&lt;=2;i++)。第一个直接就可以算出3-0 = 3 有三个数据，而后者 2-0+1个数据，多出1个加法运算，很恼火。<br>
2）	也有一定的历史原因</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[04讲复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度]]></title>
        <id>https://carrollwang.github.io//post/04-jiang-fu-za-du-fen-xi-xia-qian-xi-zui-hao-zui-pi-ping-jun-jun-tan-shi-jian-fu-za-du</id>
        <link href="https://carrollwang.github.io//post/04-jiang-fu-za-du-fen-xi-xia-qian-xi-zui-hao-zui-pi-ping-jun-jun-tan-shi-jian-fu-za-du">
        </link>
        <updated>2019-10-27T05:56:58.000Z</updated>
        <content type="html"><![CDATA[<p>一、复杂度分析的4个概念<br>
1.最坏情况时间复杂度：代码在最理想情况下执行的时间复杂度。<br>
2.最好情况时间复杂度：代码在最坏情况下执行的时间复杂度。<br>
3.平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示。<br>
4.均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。</p>
<p>二、为什么要引入这4个概念？<br>
1.同一段代码在不同情况下时间复杂度会出现量级差异，为了更全面，更准确的描述代码的时间复杂度，所以引入这4个概念。<br>
2.代码复杂度在不同情况下出现量级差别时才需要区别这四种复杂度。大多数情况下，是不需要区别分析它们的。</p>
<p>三、如何分析平均、均摊时间复杂度？<br>
1.平均时间复杂度<br>
代码在不同情况下复杂度出现量级差别，则用代码所有可能情况下执行次数的加权平均值表示。<br>
2.均摊时间复杂度<br>
两个条件满足时使用：1）代码在绝大多数情况下是低级别复杂度，只有极少数情况是高级别复杂度；2）低级别和高级别复杂度出现具有时序规律。均摊结果一般都等于低级别复杂度。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[03讲复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗]]></title>
        <id>https://carrollwang.github.io//post/shu-ju-jie-gou-yu-suan-fa</id>
        <link href="https://carrollwang.github.io//post/shu-ju-jie-gou-yu-suan-fa">
        </link>
        <updated>2019-10-27T00:59:43.000Z</updated>
        <content type="html"><![CDATA[<p>一 .为什么需要复杂度分析？</p>
<blockquote>
<p>①. 测试结果非常依赖测试环境<br>
②测试结果受数据规模的影响很大</p>
</blockquote>
<p>二 .大O复杂度表示法<br>
所有代码的执行时间T(n)与每行代码的执行次数n成正比。<br>
<img src="https://carrollwang.github.io//post-images/1572138199119.png" alt=""><br>
大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。</p>
<p>三 .时间复杂度分析<br>
1.只关注循环执行次数最多的一段代码</p>
<p>我刚才说了，大O这种复杂度表示方法只是表示一种变化趋势。我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。所以，我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了。这段核心代码执行次数的n的量级，就是整段要分析代码的时间复杂度。</p>
<pre><code class="language-java"> int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i &lt;= n; ++i) {
     sum = sum + i;
   }
   return sum;
 }
</code></pre>
<p>其中第2、3行代码都是常量级的执行时间，与n的大小无关，所以对于复杂度并没有影响。循环执行次数最多的是第4、5行代码，所以这块代码要重点分析。前面我们也讲过，这两行代码被执行了n次，所以总的时间复杂度就是O(n)。</p>
<p>2.加法法则：总复杂度等于量级最大的那段代码的复杂度</p>
<pre><code class="language-java">int cal(int n) {
   int sum_1 = 0;
   int p = 1;
   for (; p &lt; 100; ++p) {
     sum_1 = sum_1 + p;
   }

   int sum_2 = 0;
   int q = 1;
   for (; q &lt; n; ++q) {
     sum_2 = sum_2 + q;
   }
 
   int sum_3 = 0;
   int i = 1;
   int j = 1;
   for (; i &lt;= n; ++i) {
     j = 1; 
     for (; j &lt;= n; ++j) {
       sum_3 = sum_3 +  i * j;
     }
   }
 
   return sum_1 + sum_2 + sum_3;
 }
</code></pre>
<p>这个代码分为三部分，分别是求sum_1、sum_2、sum_3。我们可以分别分析每一部分的时间复杂度，然后把它们放到一块儿，再取一个量级最大的作为整段代码的复杂度。</p>
<p>第一段的时间复杂度是多少呢？这段代码循环执行了100次，所以是一个常量的执行时间，跟n的规模无关。</p>
<p>这里我要再强调一下，即便这段代码循环10000次、100000次，只要是一个已知的数，跟n无关，照样也是常量级的执行时间。当n无限大的时候，就可以忽略。尽管对代码的执行时间会有很大影响，但是回到时间复杂度的概念来说，它表示的是一个算法执行效率与数据规模增长的变化趋势，所以不管常量的执行时间多大，我们都可以忽略掉。因为它本身对增长趋势并没有影响。</p>
<p>那第二段代码和第三段代码的时间复杂度是多少呢？答案是O(n)和O(n2)，你应该能容易就分析出来，我就不啰嗦了。</p>
<p>综合这三段代码的时间复杂度，我们取其中最大的量级。所以，整段代码的时间复杂度就为O(n2)。也就是说：总的时间复杂度就等于量级最大的那段代码的时间复杂度。那我们将这个规律抽象成公式就是：</p>
<p>如果T1(n)=O(f(n))，T2(n)=O(g(n))；那么T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n))).</p>
<p>3.乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</p>
<p>如果T1(n)=O(f(n))，T2(n)=O(g(n))；那么T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n)).</p>
<p>也就是说，假设T1(n) = O(n)，T2(n) = O(n2)，则T1(n) * T2(n) = O(n3)。落实到具体的代码上，我们可以把乘法法则看成是嵌套循环，我举个例子给你解释一下。</p>
<pre><code class="language-java">int cal(int n) {
   int ret = 0; 
   int i = 1;
   for (; i &lt; n; ++i) {
     ret = ret + f(i);
   } 
 } 
 
 int f(int n) {
  int sum = 0;
  int i = 1;
  for (; i &lt; n; ++i) {
    sum = sum + i;
  } 
  return sum;
 }```
我们单独看cal()函数。假设f()只是一个普通的操作，那第4～6行的时间复杂度就是，T1(n) = O(n)。但f()函数本身不是一个简单的操作，它的时间复杂度是T2(n) = O(n)，所以，整个cal()函数的时间复杂度就是，T(n) = T1(n) * T2(n) = O(n*n) = O(n2)。



四.![](https://carrollwang.github.io//post-images/1572140610550.jpg)

提示：一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。

注意： O(m+n)、O(m*n)
```java
int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i &lt; m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j &lt; n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}```
从代码中可以看出，m和n是表示两个数据规模。我们无法事先评估m和n谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是O(m+n)

针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m)*T2(n) = O(f(m) * f(n))。

五.空间复杂度分析
时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。

```java
void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i &lt;n; ++i) {
    a[i] = i * i;
  }

  for (i = n-1; i &gt;= 0; --i) {
    print out a[i]
  }
}```

第2行代码中，我们申请了一个空间存储变量i，但是它是常量阶的，跟数据规模n没有关系，所以我们可以忽略。第3行申请了一个大小为n的int类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是O(n)。

我们常见的空间复杂度就是O(1)、O(n)、O(n2 )，像O(logn)、O(nlogn)这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。所以，对于空间复杂度，掌握刚我说的这些内容已经足够了。

六.内容小结
复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )。等你学完整个专栏之后，你就会发现几乎所有的数据结构和算法的复杂度都跑不出这几个。
![](https://carrollwang.github.io//post-images/1572141504463.jpg)</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础习题集]]></title>
        <id>https://carrollwang.github.io//post/java-ji-chu-xi-ti-ji</id>
        <link href="https://carrollwang.github.io//post/java-ji-chu-xi-ti-ji">
        </link>
        <updated>2019-10-08T07:06:54.000Z</updated>
        <content type="html"><![CDATA[<p><strong>1.if语句例题1</strong></p>
<blockquote>
<p>岳小鹏参加Java考试，他和父亲岳不群达成承诺：<br>
如果：<br>
成绩为100分时，奖励一辆BMW；<br>
成绩为(80，99]时，奖励一台iphone xs max；<br>
当成绩为[60,80]时，奖励一个 iPad；<br>
其它时，什么奖励也没有。<br>
请从键盘输入岳小鹏的期末成绩，并加以判断<br>
<strong>答案：</strong></p>
</blockquote>
<pre><code class="language-java">public class DoWhileTest {
    public static void main(String[] args) {
        //遍历100以内的偶数,并计算所有偶数的和及偶数的个数
        int num = 1;
        int sum = 0;
        int count = 0;
        do {
            if (num % 2 == 0) {
                System.out.println(num);
                sum += num;
                count++;
            }
            num++;
        } while (num &lt;= 100);
        System.out.println(&quot;总和为：&quot; + sum);
        System.out.println(&quot;个数为：&quot; + count);
    }
}  
</code></pre>
<p><strong>if语句例题2</strong><br>
编写程序：由键盘输入三个整数分别存入变量num1、num2、num3，<br>
对它们进行排序(使用 if-else if-else),并且从小到大输出。</p>
<p><strong>二维数组练习题</strong></p>
<blockquote>
<p>使用二维数组打印一个10行 杨辉三角。</p>
</blockquote>
<ul>
<li>【提示】:</li>
<li>1.第一行有1个元素，第n行有n个元素</li>
<li>2.每一行的第一个元素和最后一个元素都是1</li>
<li>3.从第三行开始，对于非第一个元素和最后一个元素的元素。即：</li>
<li>yanghui[i][j] =yanghui[i-1][j-1] + yanghui[i-1][j];</li>
</ul>
<pre><code class="language-java"> public static void main(String[] args) {
        //1.声明并初始化二维数组（动态初始化）
        int[][] yanghui = new int[10][];
        //2.给数组的元素赋值
        for (int i = 0; i &lt; yanghui.length; i++) {
            yanghui[i] = new int[i + 1];
            //2.1给首末元素赋值
            yanghui[i][0] = yanghui[i][i] = 1;
            //2.2给每行的非首末元素赋值
            if (i &gt; 1) {
                for (int j = 1; j &lt; yanghui[i].length - 1; j++) {
                    yanghui[i][j] = yanghui[i - 1][j - 1] + yanghui[i - 1][j];
                }
            }

        }
        //3.遍历二维数组
        for (int i = 0; i &lt; yanghui.length; i++) {
            for (int j = 0; j &lt; yanghui[i].length; j++) {
                System.out.print(yanghui[i][j] + &quot; &quot;);
            }
            System.out.println();
        }
    }
 





</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础笔记]]></title>
        <id>https://carrollwang.github.io//post/java-ji-chu-bi-ji</id>
        <link href="https://carrollwang.github.io//post/java-ji-chu-bi-ji">
        </link>
        <updated>2019-10-08T05:45:34.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>JDK,JRE,JVM三者之间的关系，以及JDK、JRE包含的主要结构有哪些</li>
</ol>
<p>JDK = JRE + Java的开发工具（javac.exe,java.exe,javadoc.exe）<br>
JRD = JVM + Java核心类库</p>
<p>2.为什么要配置path环境变量？如何配置？</p>
<p>JAVA_HOME = bin的上一层目录<br>
path = %JAVA_HOME%\bin</p>
<p>3.常用的几个命令行操作都有哪些？(至少4个)<br>
cd<br>
md<br>
rd<br>
del<br>
cd..<br>
cd/</p>
<p>4.为什么配置path环境变量？<br>
path环境变量：windows操作系统执行命令时所要搜寻的路径<br>
为什么要配置path:希望java的开发工具（javac.exe,java.exe)在任何的文件路径下都可以执行成功。</p>
<p>5.=与==的区别</p>
<blockquote>
<p>=是赋值，= =是判断<br>
如a=b 就是把b的值赋予给a;<br>
a==b 就是判断a等于b</p>
</blockquote>
]]></content>
    </entry>
</feed>