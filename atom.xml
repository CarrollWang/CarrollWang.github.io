<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://carrollwang.github.io/</id>
    <title>我爱你啊</title>
    <updated>2019-10-31T14:20:50.248Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://carrollwang.github.io/"/>
    <link rel="self" href="https://carrollwang.github.io//atom.xml"/>
    <subtitle>一生所求，爱与自由.</subtitle>
    <logo>https://carrollwang.github.io//images/avatar.png</logo>
    <icon>https://carrollwang.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 我爱你啊</rights>
    <entry>
        <title type="html"><![CDATA[时间复杂度O(1)和O(n)的区别]]></title>
        <id>https://carrollwang.github.io//post/shi-jian-fu-za-du-o1he-onde-qu-bie</id>
        <link href="https://carrollwang.github.io//post/shi-jian-fu-za-du-o1he-onde-qu-bie">
        </link>
        <updated>2019-10-30T14:26:51.000Z</updated>
        <content type="html"><![CDATA[<p>O(1)解析<br>
O(1)就是最低的时空复杂度了，也就是耗时/耗空间与输入数据大小无关，无论输入数据增大多少倍，耗时/耗空间都不变。 哈希算法就是典型的O(1)时间复杂度，无论数据规模多大，都可以在一次计算后找到目标（不考虑冲突的话），冲突的话很麻烦的，指向的value会做二次hash到另外一快存储区域。</p>
<p>通俗易懂的例子</p>
<p>什么是O(1)呢，就比如你是一个酒店的管理员，你负责管理酒店的钥匙，你很聪明，你把酒店的100把钥匙放在了100个格子里面存着，并且把格子从1~100进行了编号，有一天有客人来了，酒店老板说，给我拿10号房间的钥匙给我，你迅速从10号格子里面拿出钥匙给老板，速度非常快，这时候你就是一个电脑了，老板跟你说拿几号房房间的钥匙，你只需要看一眼就能知道钥匙在哪里。</p>
<p>O(n)解析<br>
比如时间复杂度为O(n)，就代表数据量增大几倍，耗时也增大几倍。</p>
<p>比如常见的遍历算法。</p>
<p>要找到一个数组里面最大的一个数，你要把n个变量都扫描一遍，操作次数为n，那么算法复杂度是O(n).</p>
<p>通俗易懂的例子</p>
<p>突然，有一天，你的老板给你说，你用100个箱子存100把钥匙，太浪费空间了，你能补能把钥匙上编号一下，然后把钥匙要用绳子穿起来，这样我们可以把这个放箱子的地方再装修一个房间出来。你想了一下，是啊，现在房价这么贵，这样能多赚点钱。所以你就不能通过上面的方法来找到钥匙了，老板跟你说，给我拿45号房间的钥匙出来，你就需要从100个钥匙里面挨个找45个房间的钥匙。<br>
————————————————<br>
版权声明：本文为CSDN博主「孤独键客」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：https://blog.csdn.net/lkp1603645756/article/details/85013126</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线性表]]></title>
        <id>https://carrollwang.github.io//post/xian-xing-biao</id>
        <link href="https://carrollwang.github.io//post/xian-xing-biao">
        </link>
        <updated>2019-10-30T12:33:41.000Z</updated>
        <content type="html"><![CDATA[<p>定义：另个或者多个数据元素的有限序列。<br>
1.首先他是一序列，也就是说，元素之间是有顺序的。<br>
2、线性表强调是有限的，元素个数是有限的。事实上，在计算机中处理的对象都是有限的，那种无限的数列，只存在于数学的概念中<br>
3.线性表元素的个数n（n&gt;=0）定义为线性表的长度，当n=0时，称为空表。<br>
4.相同类型的数据<br>
5.<img src="https://carrollwang.github.io//post-images/1572439397394.png" alt=""><br>
6.线性表的顺序存储结构，指的是用一段地址连续的存储单元一次存储线性表的数据元素。<br>
7.<img src="https://carrollwang.github.io//post-images/1572442158486.png" alt=""><br>
描述顺序存储结构需要三个属性：</p>
<blockquote>
<p>①存储空间的起始位置：数组data,它的存储位置就是存储空间的存储位置<br>
②线性表的最大存储容量：数组长度MaxSize<br>
③线性表的当前长度：length</p>
</blockquote>
<p>8.数组的长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的。<br>
线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。<br>
在任意时刻，线性表的长度应该小于等于数组的长度。<br>
数组的长度：<br>
线性表的长度：<br>
9.<img src="https://carrollwang.github.io//post-images/1572443012065.png" alt=""><br>
<img src="https://carrollwang.github.io//post-images/1572443020652.png" alt=""><br>
10.<img src="https://carrollwang.github.io//post-images/1572443516001.png" alt=""><br>
11.结点由存放数据元素的数据域和存放后继结点地址的指针域组成<br>
12.#单链表的读取</p>
<blockquote>
<p>获得链表第i个数据的算法思路<br>
a、声明一个结点p指向链表第一个结点，初始化j从1开始。<br>
b、当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1。<br>
c、若到链表末尾P为空，则说明第i个元素不存在。<br>
d、否则查找成功，返回结点P的数据。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[05讲数组：为什么很多编程语言中数组都从0开始编号]]></title>
        <id>https://carrollwang.github.io//post/05-jiang-shu-zu-wei-shi-me-hen-duo-bian-cheng-yu-yan-zhong-shu-zu-du-cong-0-kai-shi-bian-hao</id>
        <link href="https://carrollwang.github.io//post/05-jiang-shu-zu-wei-shi-me-hen-duo-bian-cheng-yu-yan-zhong-shu-zu-du-cong-0-kai-shi-bian-hao">
        </link>
        <updated>2019-10-28T08:52:19.000Z</updated>
        <content type="html"><![CDATA[<p>##数组看起来简单基础，但是很多人没有理解这个数据结构的精髓。带着为什么数组要从0开始编号，而不是从1开始的问题，进入主题。</p>
<ol>
<li>数组如何实现随机访问<br>
1）	数组是一种线性数据结构，用连续的存储空间存储相同类型数据<br>
I）	线性表：数组、链表、队列、栈 非线性表：树 图<br>
II）	连续的内存空间、相同的数据，所以数组可以随机访问，但对数组进行删除插入，为了保证数组的连续性，就要做大量的数据搬移工作<br>
a)	数组如何实现下标随机访问。<br>
引入数组再内存种的分配图，得出寻址公式<br>
b)	纠正数组和链表的错误认识。数组的查找操作时间复杂度并不是O(1)。即便是排好的数组，用二分查找，时间复杂度也是O（logn）。<br>
正确表述：数组支持随机访问，根据下标随机访问的时间复杂度为O（1）</li>
<li>低效的插入和删除<br>
1）	插入：从最好O(1) 最坏O(n) 平均O(n)<br>
2）	插入：数组若无序，插入新的元素时，可以将第K个位置元素移动到数组末尾，把心的元素，插入到第k个位置，此处复杂度为O(1)。作者举例说明<br>
3）	删除：从最好O(1) 最坏O(n) 平均O(n)<br>
4）	多次删除集中在一起，提高删除效率<br>
记录下已经被删除的数据，每次的删除操作并不是搬移数据，只是记录数据已经被删除，当数组没有更多的存储空间时，再触发一次真正的删除操作。即JVM标记清除垃圾回收算法。</li>
<li>警惕数组的访问越界问题<br>
用C语言循环越界访问的例子说明访问越界的bug。此例在《C陷阱与缺陷》出现过，很惭愧，看过但是现在也只有一丢丢印象。翻了下书，替作者加上一句话：如果用来编译这段程序的编译器按照内存地址递减的方式给变量分配内存，那么内存中的i将会被置为0，则为死循环永远出不去。</li>
<li>容器能否完全替代数组<br>
相比于数字，java中的ArrayList封装了数组的很多操作，并支持动态扩容。一旦超过村塾容量，扩容时比较耗内存，因为涉及到内存申请和数据搬移。<br>
数组适合的场景：<br>
1）	Java ArrayList 的使用涉及装箱拆箱，有一定的性能损耗，如果特别管柱性能，可以考虑数组<br>
2）	若数据大小事先已知，并且涉及的数据操作非常简单，可以使用数组<br>
3）	表示多维数组时，数组往往更加直观。<br>
4）	业务开发容器即可，底层开发，如网络框架，性能优化。选择数组。</li>
<li>解答开篇问题<br>
1）	从偏移角度理解a[0] 0为偏移量，如果从1计数，会多出K-1。增加cpu负担。为什么循环要写成for(int i = 0;i&lt;3;i++) 而不是for(int i = 0 ;i&lt;=2;i++)。第一个直接就可以算出3-0 = 3 有三个数据，而后者 2-0+1个数据，多出1个加法运算，很恼火。<br>
2）	也有一定的历史原因</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[04讲复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度]]></title>
        <id>https://carrollwang.github.io//post/04-jiang-fu-za-du-fen-xi-xia-qian-xi-zui-hao-zui-pi-ping-jun-jun-tan-shi-jian-fu-za-du</id>
        <link href="https://carrollwang.github.io//post/04-jiang-fu-za-du-fen-xi-xia-qian-xi-zui-hao-zui-pi-ping-jun-jun-tan-shi-jian-fu-za-du">
        </link>
        <updated>2019-10-27T05:56:58.000Z</updated>
        <content type="html"><![CDATA[<p>一、复杂度分析的4个概念<br>
1.最坏情况时间复杂度：代码在最理想情况下执行的时间复杂度。<br>
2.最好情况时间复杂度：代码在最坏情况下执行的时间复杂度。<br>
3.平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示。<br>
4.均摊时间复杂度：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。</p>
<p>二、为什么要引入这4个概念？<br>
1.同一段代码在不同情况下时间复杂度会出现量级差异，为了更全面，更准确的描述代码的时间复杂度，所以引入这4个概念。<br>
2.代码复杂度在不同情况下出现量级差别时才需要区别这四种复杂度。大多数情况下，是不需要区别分析它们的。</p>
<p>三、如何分析平均、均摊时间复杂度？<br>
1.平均时间复杂度<br>
代码在不同情况下复杂度出现量级差别，则用代码所有可能情况下执行次数的加权平均值表示。<br>
2.均摊时间复杂度<br>
两个条件满足时使用：1）代码在绝大多数情况下是低级别复杂度，只有极少数情况是高级别复杂度；2）低级别和高级别复杂度出现具有时序规律。均摊结果一般都等于低级别复杂度。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[03讲复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗]]></title>
        <id>https://carrollwang.github.io//post/shu-ju-jie-gou-yu-suan-fa</id>
        <link href="https://carrollwang.github.io//post/shu-ju-jie-gou-yu-suan-fa">
        </link>
        <updated>2019-10-27T00:59:43.000Z</updated>
        <content type="html"><![CDATA[<p>一 .为什么需要复杂度分析？</p>
<blockquote>
<p>①. 测试结果非常依赖测试环境<br>
②测试结果受数据规模的影响很大</p>
</blockquote>
<p>二 .大O复杂度表示法<br>
所有代码的执行时间T(n)与每行代码的执行次数n成正比。<br>
<img src="https://carrollwang.github.io//post-images/1572138199119.png" alt=""><br>
大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。</p>
<p>三 .时间复杂度分析<br>
1.只关注循环执行次数最多的一段代码</p>
<p>我刚才说了，大O这种复杂度表示方法只是表示一种变化趋势。我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。所以，我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了。这段核心代码执行次数的n的量级，就是整段要分析代码的时间复杂度。</p>
<pre><code class="language-java"> int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i &lt;= n; ++i) {
     sum = sum + i;
   }
   return sum;
 }
</code></pre>
<p>其中第2、3行代码都是常量级的执行时间，与n的大小无关，所以对于复杂度并没有影响。循环执行次数最多的是第4、5行代码，所以这块代码要重点分析。前面我们也讲过，这两行代码被执行了n次，所以总的时间复杂度就是O(n)。</p>
<p>2.加法法则：总复杂度等于量级最大的那段代码的复杂度</p>
<pre><code class="language-java">int cal(int n) {
   int sum_1 = 0;
   int p = 1;
   for (; p &lt; 100; ++p) {
     sum_1 = sum_1 + p;
   }

   int sum_2 = 0;
   int q = 1;
   for (; q &lt; n; ++q) {
     sum_2 = sum_2 + q;
   }
 
   int sum_3 = 0;
   int i = 1;
   int j = 1;
   for (; i &lt;= n; ++i) {
     j = 1; 
     for (; j &lt;= n; ++j) {
       sum_3 = sum_3 +  i * j;
     }
   }
 
   return sum_1 + sum_2 + sum_3;
 }
</code></pre>
<p>这个代码分为三部分，分别是求sum_1、sum_2、sum_3。我们可以分别分析每一部分的时间复杂度，然后把它们放到一块儿，再取一个量级最大的作为整段代码的复杂度。</p>
<p>第一段的时间复杂度是多少呢？这段代码循环执行了100次，所以是一个常量的执行时间，跟n的规模无关。</p>
<p>这里我要再强调一下，即便这段代码循环10000次、100000次，只要是一个已知的数，跟n无关，照样也是常量级的执行时间。当n无限大的时候，就可以忽略。尽管对代码的执行时间会有很大影响，但是回到时间复杂度的概念来说，它表示的是一个算法执行效率与数据规模增长的变化趋势，所以不管常量的执行时间多大，我们都可以忽略掉。因为它本身对增长趋势并没有影响。</p>
<p>那第二段代码和第三段代码的时间复杂度是多少呢？答案是O(n)和O(n2)，你应该能容易就分析出来，我就不啰嗦了。</p>
<p>综合这三段代码的时间复杂度，我们取其中最大的量级。所以，整段代码的时间复杂度就为O(n2)。也就是说：总的时间复杂度就等于量级最大的那段代码的时间复杂度。那我们将这个规律抽象成公式就是：</p>
<p>如果T1(n)=O(f(n))，T2(n)=O(g(n))；那么T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n))).</p>
<p>3.乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</p>
<p>如果T1(n)=O(f(n))，T2(n)=O(g(n))；那么T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n)).</p>
<p>也就是说，假设T1(n) = O(n)，T2(n) = O(n2)，则T1(n) * T2(n) = O(n3)。落实到具体的代码上，我们可以把乘法法则看成是嵌套循环，我举个例子给你解释一下。</p>
<pre><code class="language-java">int cal(int n) {
   int ret = 0; 
   int i = 1;
   for (; i &lt; n; ++i) {
     ret = ret + f(i);
   } 
 } 
 
 int f(int n) {
  int sum = 0;
  int i = 1;
  for (; i &lt; n; ++i) {
    sum = sum + i;
  } 
  return sum;
 }```
我们单独看cal()函数。假设f()只是一个普通的操作，那第4～6行的时间复杂度就是，T1(n) = O(n)。但f()函数本身不是一个简单的操作，它的时间复杂度是T2(n) = O(n)，所以，整个cal()函数的时间复杂度就是，T(n) = T1(n) * T2(n) = O(n*n) = O(n2)。



四.![](https://carrollwang.github.io//post-images/1572140610550.jpg)

提示：一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。

注意： O(m+n)、O(m*n)
```java
int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i &lt; m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j &lt; n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}```
从代码中可以看出，m和n是表示两个数据规模。我们无法事先评估m和n谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是O(m+n)

针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m)*T2(n) = O(f(m) * f(n))。

五.空间复杂度分析
时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。

```java
void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i &lt;n; ++i) {
    a[i] = i * i;
  }

  for (i = n-1; i &gt;= 0; --i) {
    print out a[i]
  }
}```

第2行代码中，我们申请了一个空间存储变量i，但是它是常量阶的，跟数据规模n没有关系，所以我们可以忽略。第3行申请了一个大小为n的int类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是O(n)。

我们常见的空间复杂度就是O(1)、O(n)、O(n2 )，像O(logn)、O(nlogn)这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。所以，对于空间复杂度，掌握刚我说的这些内容已经足够了。

六.内容小结
复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )。等你学完整个专栏之后，你就会发现几乎所有的数据结构和算法的复杂度都跑不出这几个。
![](https://carrollwang.github.io//post-images/1572141504463.jpg)</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础习题集]]></title>
        <id>https://carrollwang.github.io//post/java-ji-chu-xi-ti-ji</id>
        <link href="https://carrollwang.github.io//post/java-ji-chu-xi-ti-ji">
        </link>
        <updated>2019-10-08T07:06:54.000Z</updated>
        <content type="html"><![CDATA[<p><strong>1.if语句例题1</strong></p>
<blockquote>
<p>岳小鹏参加Java考试，他和父亲岳不群达成承诺：<br>
如果：<br>
成绩为100分时，奖励一辆BMW；<br>
成绩为(80，99]时，奖励一台iphone xs max；<br>
当成绩为[60,80]时，奖励一个 iPad；<br>
其它时，什么奖励也没有。<br>
请从键盘输入岳小鹏的期末成绩，并加以判断<br>
<strong>答案：</strong></p>
</blockquote>
<pre><code class="language-java">public class DoWhileTest {
    public static void main(String[] args) {
        //遍历100以内的偶数,并计算所有偶数的和及偶数的个数
        int num = 1;
        int sum = 0;
        int count = 0;
        do {
            if (num % 2 == 0) {
                System.out.println(num);
                sum += num;
                count++;
            }
            num++;
        } while (num &lt;= 100);
        System.out.println(&quot;总和为：&quot; + sum);
        System.out.println(&quot;个数为：&quot; + count);
    }
}  
</code></pre>
<p><strong>if语句例题2</strong><br>
编写程序：由键盘输入三个整数分别存入变量num1、num2、num3，<br>
对它们进行排序(使用 if-else if-else),并且从小到大输出。</p>
<p><strong>二维数组练习题</strong></p>
<blockquote>
<p>使用二维数组打印一个10行 杨辉三角。</p>
</blockquote>
<ul>
<li>【提示】:</li>
<li>1.第一行有1个元素，第n行有n个元素</li>
<li>2.每一行的第一个元素和最后一个元素都是1</li>
<li>3.从第三行开始，对于非第一个元素和最后一个元素的元素。即：</li>
<li>yanghui[i][j] =yanghui[i-1][j-1] + yanghui[i-1][j];</li>
</ul>
<pre><code class="language-java"> public static void main(String[] args) {
        //1.声明并初始化二维数组（动态初始化）
        int[][] yanghui = new int[10][];
        //2.给数组的元素赋值
        for (int i = 0; i &lt; yanghui.length; i++) {
            yanghui[i] = new int[i + 1];
            //2.1给首末元素赋值
            yanghui[i][0] = yanghui[i][i] = 1;
            //2.2给每行的非首末元素赋值
            if (i &gt; 1) {
                for (int j = 1; j &lt; yanghui[i].length - 1; j++) {
                    yanghui[i][j] = yanghui[i - 1][j - 1] + yanghui[i - 1][j];
                }
            }

        }
        //3.遍历二维数组
        for (int i = 0; i &lt; yanghui.length; i++) {
            for (int j = 0; j &lt; yanghui[i].length; j++) {
                System.out.print(yanghui[i][j] + &quot; &quot;);
            }
            System.out.println();
        }
    }
 





</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础笔记]]></title>
        <id>https://carrollwang.github.io//post/java-ji-chu-bi-ji</id>
        <link href="https://carrollwang.github.io//post/java-ji-chu-bi-ji">
        </link>
        <updated>2019-10-08T05:45:34.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>JDK,JRE,JVM三者之间的关系，以及JDK、JRE包含的主要结构有哪些</li>
</ol>
<p>JDK = JRE + Java的开发工具（javac.exe,java.exe,javadoc.exe）<br>
JRD = JVM + Java核心类库</p>
<p>2.为什么要配置path环境变量？如何配置？</p>
<p>JAVA_HOME = bin的上一层目录<br>
path = %JAVA_HOME%\bin</p>
<p>3.常用的几个命令行操作都有哪些？(至少4个)<br>
cd<br>
md<br>
rd<br>
del<br>
cd..<br>
cd/</p>
<p>4.为什么配置path环境变量？<br>
path环境变量：windows操作系统执行命令时所要搜寻的路径<br>
为什么要配置path:希望java的开发工具（javac.exe,java.exe)在任何的文件路径下都可以执行成功。</p>
<p>5.=与==的区别</p>
<blockquote>
<p>=是赋值，= =是判断<br>
如a=b 就是把b的值赋予给a;<br>
a==b 就是判断a等于b</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常用的DOS命令]]></title>
        <id>https://carrollwang.github.io//post/wu-wu-wo</id>
        <link href="https://carrollwang.github.io//post/wu-wu-wo">
        </link>
        <updated>2019-10-05T05:49:35.000Z</updated>
        <content type="html"><![CDATA[<p>dir : 列出当前目录下的文件以及文件夹<br>
md : 创建目录<br>
rd : 删除目录<br>
cd : 进入指定目录<br>
cd.. : 退回到上一级目录<br>
cd: 退回到根目录<br>
del : 删除文件<br>
exit : 退出 dos 命令行<br>
补充：echo javase&gt;1.doc<br>
常用快捷键<br>
← →：移动光标<br>
↑ ↓：调阅历史操作命令<br>
Delete和Backspace：删除字符</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[参数]]></title>
        <id>https://carrollwang.github.io//post/can-shu</id>
        <link href="https://carrollwang.github.io//post/can-shu">
        </link>
        <updated>2019-10-05T05:45:31.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<!-- more -->
<p>参数🤗</p>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello World!]]></title>
        <id>https://carrollwang.github.io//post/hello-gridea</id>
        <link href="https://carrollwang.github.io//post/hello-gridea">
        </link>
        <updated>2019-09-04T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>Hello World!</p>
]]></content>
    </entry>
</feed>