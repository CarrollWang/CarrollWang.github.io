<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://carrollwang.github.io/</id>
    <title>我爱你啊</title>
    <updated>2019-10-27T01:58:40.725Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://carrollwang.github.io/"/>
    <link rel="self" href="https://carrollwang.github.io//atom.xml"/>
    <subtitle>一生所求，爱与自由.</subtitle>
    <logo>https://carrollwang.github.io//images/avatar.png</logo>
    <icon>https://carrollwang.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, 我爱你啊</rights>
    <entry>
        <title type="html"><![CDATA[数据结构与算法]]></title>
        <id>https://carrollwang.github.io//post/shu-ju-jie-gou-yu-suan-fa</id>
        <link href="https://carrollwang.github.io//post/shu-ju-jie-gou-yu-suan-fa">
        </link>
        <updated>2019-10-27T00:59:43.000Z</updated>
        <content type="html"><![CDATA[<p>一 .为什么需要复杂度分析？</p>
<blockquote>
<p>①. 测试结果非常依赖测试环境<br>
②测试结果受数据规模的影响很大</p>
</blockquote>
<p>二 .大O复杂度表示法<br>
所有代码的执行时间T(n)与每行代码的执行次数n成正比。<br>
<img src="https://carrollwang.github.io//post-images/1572138199119.png" alt=""><br>
大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。</p>
<p>三 .时间复杂度分析<br>
1.只关注循环执行次数最多的一段代码</p>
<p>我刚才说了，大O这种复杂度表示方法只是表示一种变化趋势。我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。所以，我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了。这段核心代码执行次数的n的量级，就是整段要分析代码的时间复杂度。</p>
<pre><code class="language-java"> int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i &lt;= n; ++i) {
     sum = sum + i;
   }
   return sum;
 }
</code></pre>
<p>其中第2、3行代码都是常量级的执行时间，与n的大小无关，所以对于复杂度并没有影响。循环执行次数最多的是第4、5行代码，所以这块代码要重点分析。前面我们也讲过，这两行代码被执行了n次，所以总的时间复杂度就是O(n)。</p>
<p>2.加法法则：总复杂度等于量级最大的那段代码的复杂度</p>
<pre><code class="language-java">int cal(int n) {
   int sum_1 = 0;
   int p = 1;
   for (; p &lt; 100; ++p) {
     sum_1 = sum_1 + p;
   }

   int sum_2 = 0;
   int q = 1;
   for (; q &lt; n; ++q) {
     sum_2 = sum_2 + q;
   }
 
   int sum_3 = 0;
   int i = 1;
   int j = 1;
   for (; i &lt;= n; ++i) {
     j = 1; 
     for (; j &lt;= n; ++j) {
       sum_3 = sum_3 +  i * j;
     }
   }
 
   return sum_1 + sum_2 + sum_3;
 }
</code></pre>
<p>这个代码分为三部分，分别是求sum_1、sum_2、sum_3。我们可以分别分析每一部分的时间复杂度，然后把它们放到一块儿，再取一个量级最大的作为整段代码的复杂度。</p>
<p>第一段的时间复杂度是多少呢？这段代码循环执行了100次，所以是一个常量的执行时间，跟n的规模无关。</p>
<p>这里我要再强调一下，即便这段代码循环10000次、100000次，只要是一个已知的数，跟n无关，照样也是常量级的执行时间。当n无限大的时候，就可以忽略。尽管对代码的执行时间会有很大影响，但是回到时间复杂度的概念来说，它表示的是一个算法执行效率与数据规模增长的变化趋势，所以不管常量的执行时间多大，我们都可以忽略掉。因为它本身对增长趋势并没有影响。</p>
<p>那第二段代码和第三段代码的时间复杂度是多少呢？答案是O(n)和O(n2)，你应该能容易就分析出来，我就不啰嗦了。</p>
<p>综合这三段代码的时间复杂度，我们取其中最大的量级。所以，整段代码的时间复杂度就为O(n2)。也就是说：总的时间复杂度就等于量级最大的那段代码的时间复杂度。那我们将这个规律抽象成公式就是：</p>
<p>如果T1(n)=O(f(n))，T2(n)=O(g(n))；那么T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n))).</p>
<p>3.乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</p>
<p>如果T1(n)=O(f(n))，T2(n)=O(g(n))；那么T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n)).</p>
<p>也就是说，假设T1(n) = O(n)，T2(n) = O(n2)，则T1(n) * T2(n) = O(n3)。落实到具体的代码上，我们可以把乘法法则看成是嵌套循环，我举个例子给你解释一下。</p>
<pre><code class="language-java">int cal(int n) {
   int ret = 0; 
   int i = 1;
   for (; i &lt; n; ++i) {
     ret = ret + f(i);
   } 
 } 
 
 int f(int n) {
  int sum = 0;
  int i = 1;
  for (; i &lt; n; ++i) {
    sum = sum + i;
  } 
  return sum;
 }```
我们单独看cal()函数。假设f()只是一个普通的操作，那第4～6行的时间复杂度就是，T1(n) = O(n)。但f()函数本身不是一个简单的操作，它的时间复杂度是T2(n) = O(n)，所以，整个cal()函数的时间复杂度就是，T(n) = T1(n) * T2(n) = O(n*n) = O(n2)。



四.![](https://carrollwang.github.io//post-images/1572140610550.jpg)

提示：一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。

注意： O(m+n)、O(m*n)
```java
int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i &lt; m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j &lt; n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}```
从代码中可以看出，m和n是表示两个数据规模。我们无法事先评估m和n谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是O(m+n)

针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m)*T2(n) = O(f(m) * f(n))。

五.空间复杂度分析
时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。

```java
void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i &lt;n; ++i) {
    a[i] = i * i;
  }

  for (i = n-1; i &gt;= 0; --i) {
    print out a[i]
  }
}```

第2行代码中，我们申请了一个空间存储变量i，但是它是常量阶的，跟数据规模n没有关系，所以我们可以忽略。第3行申请了一个大小为n的int类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是O(n)。

我们常见的空间复杂度就是O(1)、O(n)、O(n2 )，像O(logn)、O(nlogn)这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。所以，对于空间复杂度，掌握刚我说的这些内容已经足够了。

六.内容小结
复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )。等你学完整个专栏之后，你就会发现几乎所有的数据结构和算法的复杂度都跑不出这几个。
![](https://carrollwang.github.io//post-images/1572141504463.jpg)</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础习题集]]></title>
        <id>https://carrollwang.github.io//post/java-ji-chu-xi-ti-ji</id>
        <link href="https://carrollwang.github.io//post/java-ji-chu-xi-ti-ji">
        </link>
        <updated>2019-10-08T07:06:54.000Z</updated>
        <content type="html"><![CDATA[<p><strong>1.if语句例题1</strong></p>
<blockquote>
<p>岳小鹏参加Java考试，他和父亲岳不群达成承诺：<br>
如果：<br>
成绩为100分时，奖励一辆BMW；<br>
成绩为(80，99]时，奖励一台iphone xs max；<br>
当成绩为[60,80]时，奖励一个 iPad；<br>
其它时，什么奖励也没有。<br>
请从键盘输入岳小鹏的期末成绩，并加以判断<br>
<strong>答案：</strong></p>
</blockquote>
<pre><code class="language-java">public class DoWhileTest {
    public static void main(String[] args) {
        //遍历100以内的偶数,并计算所有偶数的和及偶数的个数
        int num = 1;
        int sum = 0;
        int count = 0;
        do {
            if (num % 2 == 0) {
                System.out.println(num);
                sum += num;
                count++;
            }
            num++;
        } while (num &lt;= 100);
        System.out.println(&quot;总和为：&quot; + sum);
        System.out.println(&quot;个数为：&quot; + count);
    }
}  
</code></pre>
<p><strong>if语句例题2</strong><br>
编写程序：由键盘输入三个整数分别存入变量num1、num2、num3，<br>
对它们进行排序(使用 if-else if-else),并且从小到大输出。</p>
<p><strong>二维数组练习题</strong></p>
<blockquote>
<p>使用二维数组打印一个10行 杨辉三角。</p>
</blockquote>
<ul>
<li>【提示】:</li>
<li>1.第一行有1个元素，第n行有n个元素</li>
<li>2.每一行的第一个元素和最后一个元素都是1</li>
<li>3.从第三行开始，对于非第一个元素和最后一个元素的元素。即：</li>
<li>yanghui[i][j] =yanghui[i-1][j-1] + yanghui[i-1][j];</li>
</ul>
<pre><code class="language-java"> public static void main(String[] args) {
        //1.声明并初始化二维数组（动态初始化）
        int[][] yanghui = new int[10][];
        //2.给数组的元素赋值
        for (int i = 0; i &lt; yanghui.length; i++) {
            yanghui[i] = new int[i + 1];
            //2.1给首末元素赋值
            yanghui[i][0] = yanghui[i][i] = 1;
            //2.2给每行的非首末元素赋值
            if (i &gt; 1) {
                for (int j = 1; j &lt; yanghui[i].length - 1; j++) {
                    yanghui[i][j] = yanghui[i - 1][j - 1] + yanghui[i - 1][j];
                }
            }

        }
        //3.遍历二维数组
        for (int i = 0; i &lt; yanghui.length; i++) {
            for (int j = 0; j &lt; yanghui[i].length; j++) {
                System.out.print(yanghui[i][j] + &quot; &quot;);
            }
            System.out.println();
        }
    }
 





</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础笔记]]></title>
        <id>https://carrollwang.github.io//post/java-ji-chu-bi-ji</id>
        <link href="https://carrollwang.github.io//post/java-ji-chu-bi-ji">
        </link>
        <updated>2019-10-08T05:45:34.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>JDK,JRE,JVM三者之间的关系，以及JDK、JRE包含的主要结构有哪些</li>
</ol>
<p>JDK = JRE + Java的开发工具（javac.exe,java.exe,javadoc.exe）<br>
JRD = JVM + Java核心类库</p>
<p>2.为什么要配置path环境变量？如何配置？</p>
<p>JAVA_HOME = bin的上一层目录<br>
path = %JAVA_HOME%\bin</p>
<p>3.常用的几个命令行操作都有哪些？(至少4个)<br>
cd<br>
md<br>
rd<br>
del<br>
cd..<br>
cd/</p>
<p>4.为什么配置path环境变量？<br>
path环境变量：windows操作系统执行命令时所要搜寻的路径<br>
为什么要配置path:希望java的开发工具（javac.exe,java.exe)在任何的文件路径下都可以执行成功。</p>
<p>5.=与==的区别</p>
<blockquote>
<p>=是赋值，= =是判断<br>
如a=b 就是把b的值赋予给a;<br>
a==b 就是判断a等于b</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[常用的DOS命令]]></title>
        <id>https://carrollwang.github.io//post/wu-wu-wo</id>
        <link href="https://carrollwang.github.io//post/wu-wu-wo">
        </link>
        <updated>2019-10-05T05:49:35.000Z</updated>
        <content type="html"><![CDATA[<p>dir : 列出当前目录下的文件以及文件夹<br>
md : 创建目录<br>
rd : 删除目录<br>
cd : 进入指定目录<br>
cd.. : 退回到上一级目录<br>
cd: 退回到根目录<br>
del : 删除文件<br>
exit : 退出 dos 命令行<br>
补充：echo javase&gt;1.doc<br>
常用快捷键<br>
← →：移动光标<br>
↑ ↓：调阅历史操作命令<br>
Delete和Backspace：删除字符</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[参数]]></title>
        <id>https://carrollwang.github.io//post/can-shu</id>
        <link href="https://carrollwang.github.io//post/can-shu">
        </link>
        <updated>2019-10-05T05:45:31.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<!-- more -->
<p>参数🤗</p>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello World!]]></title>
        <id>https://carrollwang.github.io//post/hello-gridea</id>
        <link href="https://carrollwang.github.io//post/hello-gridea">
        </link>
        <updated>2019-09-04T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>Hello World!</p>
]]></content>
    </entry>
</feed>